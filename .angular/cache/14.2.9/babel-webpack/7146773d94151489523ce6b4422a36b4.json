{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Kgomotso/Documents/kgdev/traffic-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/Kgomotso/Documents/kgdev/traffic-app/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nconst readline = require('readline');\n\nconst AbstractGeocoder = require('./abstractgeocoder');\n\nconst ValueError = require('./../error/valueerror');\n\nconst OPTIONS = ['apiKey', 'appId', 'appCode', 'language', 'politicalView', 'country', 'state', 'production'];\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (appId, appCode, language, politicalView, country, state, production)\n */\n\nclass HereGeocoder extends AbstractGeocoder {\n  constructor(httpAdapter, options) {\n    super(httpAdapter, options);\n    this.options = options;\n    OPTIONS.forEach(option => {\n      if (!options[option] || options[option] == 'undefined') {\n        this.options[option] = null;\n      }\n    });\n\n    if (!this.options.apiKey && !(this.options.appId && this.options.appCode)) {\n      throw new Error('You must specify apiKey to use Here Geocoder');\n    }\n  }\n  /**\n   * Geocode\n   * @param <string>   value    Value to geocode (Address)\n   * @param <function> callback Callback method\n   */\n\n\n  _geocode(value, callback) {\n    var _this = this;\n\n    var params = this._prepareQueryString();\n\n    if (value.address) {\n      if (value.language) {\n        params.language = value.language;\n      }\n\n      if (value.politicalView) {\n        params.politicalview = value.politicalView;\n      }\n\n      if (value.country) {\n        params.country = value.country;\n\n        if (value.state) {\n          params.state = value.state;\n        } else {\n          delete params.state;\n        }\n      }\n\n      if (value.zipcode) {\n        params.postalcode = value.zipcode;\n      }\n\n      params.searchtext = value.address;\n    } else {\n      params.searchtext = value;\n    }\n\n    this.httpAdapter.get(this._geocodeEndpoint, params, function (err, result) {\n      var results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        if (result.type === 'ApplicationError') {\n          return callback(new ValueError(result.Details), results);\n        }\n\n        if (result.error === 'Unauthorized') {\n          return callback(new ValueError(result.error_description), results);\n        }\n\n        var view = result.Response.View[0];\n\n        if (!view) {\n          return callback(false, results);\n        } // Format each geocoding result\n\n\n        results = view.Result.map(_this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n  /**\n   * Reverse geocoding\n   * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n   * @param <function> callback Callback method\n   */\n\n\n  _reverse(query, callback) {\n    var lat = query.lat;\n    var lng = query.lon;\n\n    var _this = this;\n\n    var params = this._prepareQueryString();\n\n    params.pos = lat + ',' + lng;\n    params.mode = 'trackPosition';\n    this.httpAdapter.get(this._reverseEndpoint, params, function (err, result) {\n      var results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        var view = result.Response.View[0];\n\n        if (!view) {\n          return callback(false, results);\n        } // Format each geocoding result\n\n\n        results = view.Result.map(_this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n\n  _formatResult(result) {\n    var location = result.Location || {};\n    var address = location.Address || {};\n    var i;\n    var extractedObj = {\n      formattedAddress: address.Label || null,\n      latitude: location.DisplayPosition.Latitude,\n      longitude: location.DisplayPosition.Longitude,\n      country: null,\n      countryCode: address.Country || null,\n      state: address.State || null,\n      county: address.County || null,\n      city: address.City || null,\n      zipcode: address.PostalCode || null,\n      district: address.District || null,\n      streetName: address.Street || null,\n      streetNumber: address.HouseNumber || null,\n      building: address.Building || null,\n      extra: {\n        herePlaceId: location.LocationId || null,\n        confidence: result.Relevance || 0\n      },\n      administrativeLevels: {}\n    };\n\n    for (i = 0; i < address.AdditionalData.length; i++) {\n      var additionalData = address.AdditionalData[i];\n\n      switch (additionalData.key) {\n        //Country 2-digit code\n        case 'Country2':\n          extractedObj.countryCode = additionalData.value;\n          break;\n        //Country name\n\n        case 'CountryName':\n          extractedObj.country = additionalData.value;\n          break;\n        //State name\n\n        case 'StateName':\n          extractedObj.administrativeLevels.level1long = additionalData.value;\n          extractedObj.state = additionalData.value;\n          break;\n        //County name\n\n        case 'CountyName':\n          extractedObj.administrativeLevels.level2long = additionalData.value;\n          extractedObj.county = additionalData.value;\n      }\n    }\n\n    return extractedObj;\n  }\n\n  _prepareQueryString() {\n    var params = {\n      additionaldata: 'Country2,true',\n      gen: 8\n    }; // Deprecated\n\n    if (this.options.appId) {\n      params.app_id = this.options.appId;\n    } // Deprecated\n\n\n    if (this.options.appCode) {\n      params.app_code = this.options.appCode;\n    }\n\n    if (this.options.apiKey) {\n      params.apiKey = this.options.apiKey;\n    }\n\n    if (this.options.language) {\n      params.language = this.options.language;\n    }\n\n    if (this.options.politicalView) {\n      params.politicalview = this.options.politicalView;\n    }\n\n    if (this.options.country) {\n      params.country = this.options.country;\n    }\n\n    if (this.options.state) {\n      params.state = this.options.state;\n    }\n\n    if (this.options.limit) {\n      params.maxresults = this.options.limit;\n    }\n\n    return params;\n  }\n\n  _batchGeocode(values, callback) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const jobId = yield _this2.__createJob(values);\n        yield _this2.__pollJobStatus(jobId);\n        const rawResults = yield _this2._getJobResults(jobId);\n\n        const results = _this2.__parseBatchResults(rawResults);\n\n        callback(false, results);\n      } catch (error) {\n        callback(error, null);\n      }\n    })();\n  }\n\n  __createJob(values) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        country\n      } = _this3.options;\n      const body = `recId|searchText${country ? '|country' : ''}` + '\\n' + values.map((value, ix) => `${ix + 1}|\"${value}\"${country ? `|${country}` : ''}`).join(' \\n') + '\\n';\n      const params = { ..._this3._prepareQueryString(),\n        action: 'run',\n        outdelim: '|',\n        indelim: '|',\n        header: false,\n        outputcombined: true,\n        outcols: 'latitude,longitude,locationLabel,houseNumber,street,district,city,postalCode,county,state,addressDetailsCountry,country,building,locationId'\n      };\n      const options = {\n        body,\n        headers: {\n          'content-type': 'text/plain',\n          accept: 'application/json'\n        }\n      };\n      const creteJobReq = yield new Promise((resolve, reject) => {\n        _this3.httpAdapter.post(_this3._batchGeocodeEndpoint, params, options, (err, result) => {\n          if (err) return reject(err);\n          resolve(result);\n        });\n      });\n      const jobRes = yield creteJobReq.json();\n\n      if (jobRes.type === 'ApplicationError') {\n        throw new Error(jobRes.Details);\n      }\n\n      return jobRes.Response.MetaInfo.RequestId;\n    })();\n  }\n\n  __pollJobStatus(jobId) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let completed = false;\n      let stalledResultsCount = 500;\n      const url = `${_this4._batchGeocodeEndpoint}/${jobId}`;\n      const params = { ..._this4._prepareQueryString(),\n        action: 'status'\n      };\n\n      for (; !completed && stalledResultsCount > 0; stalledResultsCount--) {\n        const jobStatus = yield new Promise((resolve, reject) => {\n          _this4.httpAdapter.get(url, params, (err, result) => {\n            if (err) return reject(err);\n            resolve(result);\n          });\n        });\n\n        if (jobStatus.Response.Status === 'completed') {\n          completed = true;\n          break;\n        }\n      }\n\n      if (!completed) {\n        throw new Error('Job timeout');\n      }\n    })();\n  }\n\n  _getJobResults(jobId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // fetch job results\n      const params = { ..._this5._prepareQueryString(),\n        outputcompressed: false\n      };\n      const jobResult = yield new Promise((resolve, reject) => {\n        _this5.httpAdapter.get(`${_this5._batchGeocodeEndpoint}/${jobId}/result`, params, (err, result) => {\n          if (err) return reject(err);\n          resolve(result);\n        }, true);\n      });\n      const jobResultLineReadeer = readline.createInterface({\n        input: jobResult.body,\n        crlfDelay: Infinity\n      });\n      const res = [];\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(jobResultLineReadeer), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const line = _step.value;\n          const [recId,,,\n          /*seqNumber*/\n\n          /*seqLength*/\n          latitude, longitude, locationLabel, houseNumber, street, district, city, postalCode, county, state, addressDetailsCountry, country, building, locationId] = line.split('|');\n          const index = Number(recId) - 1; // minus one because our index starts at 0 and theirs at 1\n\n          res[index] = res[index] || {\n            error: null,\n            values: []\n          };\n          res[index].values.push({\n            latitude: Number(latitude),\n            longitude: Number(longitude),\n            houseNumber,\n            street,\n            locationLabel,\n            district,\n            city,\n            postalCode,\n            county,\n            state,\n            addressDetailsCountry,\n            // country name. See formatting\n            country,\n            // contry code. See formatting\n            building,\n            locationId\n          });\n        } // fetch job erros sepparately\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      const jobErrors = yield new Promise((resolve, reject) => {\n        _this5.httpAdapter.get(`${_this5._batchGeocodeEndpoint}/${jobId}/errors`, params, (err, result) => {\n          if (err) return reject(err);\n          resolve(result);\n        }, true);\n      });\n      const jobErrorsLineReader = readline.createInterface({\n        input: jobErrors.body,\n        crlfDelay: Infinity\n      });\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(jobErrorsLineReader), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n          const line = _step2.value;\n          const matches = line.match(/Line Number:(?<index>\\d+)\\s+(?<line>.*)/);\n\n          if (matches && matches.groups && matches.index) {\n            const index = Number(matches.groups.index) - 2; // minus one because the first line is the header & one less because our index starts at 0 while theirs at 1\n\n            res[index] = res[index] || {\n              error: null,\n              values: []\n            };\n            res[index].error = matches.groups.line;\n          } else {\n            throw new Error(`Unexpected error line format: \"${line}\"`);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return res;\n    })();\n  }\n\n  __parseBatchResults(results) {\n    return results.map(result => {\n      const {\n        values,\n        error\n      } = result;\n      return {\n        error,\n        value: values.map(value => {\n          const {\n            latitude,\n            longitude,\n            district,\n            city,\n            county,\n            state,\n            addressDetailsCountry,\n            country,\n            building\n          } = value;\n          return {\n            formattedAddress: value.locationLabel,\n            latitude,\n            longitude,\n            country: addressDetailsCountry,\n            countryCode: country,\n            state,\n            county,\n            city,\n            zipcode: value.postalCode,\n            district,\n            streetName: value.street,\n            streetNumber: value.houseNumber,\n            building,\n            extra: {\n              herePlaceId: value.locationId,\n              confidence: null\n            },\n            provider: 'here'\n          };\n        })\n      };\n    });\n  }\n\n}\n\nObject.defineProperties(HereGeocoder.prototype, {\n  // Here geocoding API endpoint\n  _geocodeEndpoint: {\n    get: function () {\n      return 'https://geocoder.ls.hereapi.com/6.2/geocode.json';\n    }\n  },\n  // Here reverse geocoding API endpoint\n  _reverseEndpoint: {\n    get: function () {\n      return 'https://reverse.geocoder.ls.hereapi.com/6.2/reversegeocode.json';\n    }\n  },\n  // Here batch geocoding API endpoint\n  _batchGeocodeEndpoint: {\n    get: function () {\n      return 'https://batch.geocoder.ls.hereapi.com/6.2/jobs';\n    }\n  }\n});\nmodule.exports = HereGeocoder;","map":null,"metadata":{},"sourceType":"script"}